<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用antisamy防止xss注入]]></title>
    <url>%2Farticles%2Fprevent-xss-with-antisamy-in-java%2F</url>
    <content type="text"><![CDATA[Java中处理xss的方式有多种，一般使用html entity转义，校验输入，清理有危害代码片段等方法。转义字符串长度会发生变化，可能影响到持久化操作。如果页面中不允许编辑富文本，可以采用此方式；相反，这种方式会影响html展示。校验输入可以在数据提交前防止用户添加特殊字符，但不是主要防御方法，只是有助于减少xss漏洞。清理是一种强有力的防御措施，清除可能有害的标记，将不可接受的用户输入更改为可接受的格式，以确保接收到的数据不会对用户以及数据库造成损害。在允许使用html的站点上，这种方式效果较好。实际处理中，一般采用以上几种方式组合使用，但仍不能涵盖所有xss攻击，安全测试必不可少！下面就清理有害代码的来做一次实践，利用了antisamy来完成有害代码的清理，jsoup等其他工具也可以做到。添加maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.owasp.antisamy&lt;/groupId&gt; &lt;artifactId&gt;antisamy&lt;/artifactId&gt; &lt;version&gt;1.5.8&lt;/version&gt;&lt;/dependency&gt;根据antisamy api编写相关工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.io.IOException;import org.owasp.esapi.ESAPI;import org.owasp.validator.html.AntiSamy;import org.owasp.validator.html.CleanResults;import org.owasp.validator.html.Policy;import org.owasp.validator.html.PolicyException;import org.owasp.validator.html.ScanException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.core.io.DefaultResourceLoader;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;public class XssUtils &#123; private final static Logger logger = LoggerFactory.getLogger(XssUtils.class); private static Policy policy = null; static&#123; ResourceLoader resourceLoader = new DefaultResourceLoader(); //加载规则文件，antisamy提供了多份文件供参考 Resource resource = resourceLoader.getResource("classpath:/antisamy.xml"); try &#123; policy = Policy.getInstance(resource.getURL().getPath()); &#125; catch (PolicyException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static String encode(String value)&#123; if(value == null || value.length() == 0) &#123; return value; &#125; value = ESAPI.encoder().canonicalize(value); return ESAPI.encoder().encodeForHTML(value); &#125; public static String[] encode(String[] values)&#123; if(values == null || values.length == 0)&#123; return values; &#125; int len = values.length; String[] _values = new String[len]; for(int i = 0; i &lt; len; i++)&#123; _values[i] = encode(values[i]); &#125; return _values; &#125; public static String clean(String value)&#123; AntiSamy antiSamy = new AntiSamy(); try &#123; final CleanResults cr = antiSamy.scan(value, policy); return cr.getCleanHTML(); &#125; catch (ScanException | PolicyException e) &#123; logger.error("invoke xss clean error", e); &#125; return value; &#125; public static String[] clean(String[] values)&#123; if(values == null || values.length == 0)&#123; return values; &#125; int len = values.length; String[] _values = new String[len]; for(int i = 0; i &lt; len; i++)&#123; _values[i] = clean(values[i]); &#125; return _values; &#125;&#125;使用filter处理HttpServletRequest，依次编写以下代码自定义HttpServletRequestWrapper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.HashMap;import java.util.Map;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import com.sw.busi.utils.XssUtils;public class XssCleanHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; public XssCleanHttpServletRequestWrapper(HttpServletRequest request) &#123; super(request); &#125; public String getQueryString() &#123; String value = super.getQueryString(); if (value != null) &#123; value = XssUtils.clean(value); &#125; return value; &#125; /** * 覆盖getParameter方法，将参数名和参数值都做xss过滤。&lt;br/&gt; * 如果需要获得原始的值，则通过super.getParameterValues(name)来获取&lt;br/&gt; * getParameterNames,getParameterValues和getParameterMap也可能需要覆盖 */ public String getParameter(String name) &#123; String value = super.getParameter(XssUtils.clean(name)); if (value != null) &#123; value = XssUtils.clean(value); &#125; return value; &#125; public String[] getParameterValues(String name) &#123; String[]parameters=super.getParameterValues(name); if (parameters==null||parameters.length == 0) &#123; return null; &#125; for (int i = 0; i &lt; parameters.length; i++) &#123; parameters[i] = XssUtils.clean(parameters[i]); &#125; return parameters; &#125; public Map&lt;String, String[]&gt; getParameterMap() &#123; Map&lt;String, String[]&gt; params = super.getParameterMap(); if (params==null || params.size() == 0) &#123; return params; &#125; int capacity = (int) ((float) params.size() / 0.75F + 1.0F); Map&lt;String, String[]&gt; _params = new HashMap&lt;String, String[]&gt;(capacity); for (Map.Entry&lt;String, String[]&gt; e : params.entrySet()) &#123; String key = e.getKey(); String[] values = e.getValue(); for (int i = 0; i &lt; values.length; i++) &#123; values[i] = XssUtils.clean(values[i]); &#125; _params.put(key, values); &#125; return _params; &#125; /** * 覆盖getHeader方法，将参数名和参数值都做xss过滤。&lt;br/&gt; * 如果需要获得原始的值，则通过super.getHeaders(name)来获取&lt;br/&gt; getHeaderNames 也可能需要覆盖 */ public String getHeader(String name) &#123; String value = super.getHeader(XssUtils.clean(name)); if (value != null) &#123; value = XssUtils.clean(value); &#125; return value; &#125;&#125;自定义filter1234567891011121314151617181920212223242526import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;public class XssFilter implements Filter &#123; protected FilterConfig filterConfig = null; public void init(FilterConfig filterConfig) throws ServletException &#123; this.filterConfig = filterConfig; &#125; public void destroy() &#123; this.filterConfig = null; &#125; public void doFilter(ServletRequest request, ServletResponse response,FilterChain chain) throws IOException, ServletException &#123; chain.doFilter(new XssCleanHttpServletRequestWrapper((HttpServletRequest) request), response); &#125;&#125;若使用spring mvc，且使用了@RequestBody的方式绑定参数（spring内部封装了httpservletrequest的装配器，使用了getInputStream的方式获取请求体，并转换为对应的实体），通过filter的方式就无法满足了，笔者对spring mvc的序列化与反序列化进行了修改，这里以jackson为示例，编写代码。为MappingJackson2HttpMessageConverter的objectMapper注入自定义的实例对象编写自定义ObjectMapper的实现1234567891011121314151617import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.module.SimpleModule;import com.sw.busi.json.jackson.databind.deser.StringDeserializer;import com.sw.busi.json.jackson.databind.ser.StringSerializer;public class CustomObjectMapper extends ObjectMapper &#123; private static final long serialVersionUID = -8543006375974774016L; public CustomObjectMapper()&#123; SimpleModule simpleModule = new SimpleModule(); //序列化与反序列化字符串，使用了xss clean simpleModule.addSerializer(String.class, StringSerializer.instance); simpleModule.addDeserializer(String.class, StringDeserializer.instance); this.registerModule(simpleModule); &#125;&#125;编写自定义StringSerializer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.IOException;import java.lang.reflect.Type;import com.fasterxml.jackson.core.*;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.JsonMappingException;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.SerializerProvider;import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;import com.fasterxml.jackson.databind.ser.std.NonTypedScalarSerializerBase;import com.sw.busi.utils.XssUtils;/** * This is the special serializer for regular &#123;@link java.lang.String&#125;s. *&lt;p&gt; * Since this is one of "native" types, no type information is ever * included on serialization (unlike for most scalar types as of 1.5) */public final class StringSerializer extends NonTypedScalarSerializerBase&lt;String&gt; &#123; private static final long serialVersionUID = 1L; public static final StringSerializer instance = new StringSerializer(); public StringSerializer() &#123; super(String.class); &#125; /** * For Strings, both null and Empty String qualify for emptiness. */ @Override @Deprecated public boolean isEmpty(String value) &#123; return (value == null) || (value.length() == 0); &#125; @Override public boolean isEmpty(SerializerProvider prov, String value) &#123; return (value == null) || (value.length() == 0); &#125; @Override public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException &#123; jgen.writeString(XssUtils.clean(value)); &#125; @Override public JsonNode getSchema(SerializerProvider provider, Type typeHint) &#123; return createSchemaNode("string", true); &#125; @Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException &#123; if (visitor != null) visitor.expectStringFormat(typeHint); &#125;&#125;编写StringDeserializer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.io.IOException;import com.fasterxml.jackson.core.Base64Variants;import com.fasterxml.jackson.core.JsonParser;import com.fasterxml.jackson.core.JsonToken;import com.fasterxml.jackson.databind.DeserializationContext;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;import com.sw.busi.utils.XssUtils;//去掉注解，防止自定义反序列化器被认为是标准实现，从而反序列化String[] collection&lt;String&gt; Map&lt;*, String&gt; 无效// com.fasterxml.jackson.databind.util.ClassUtil.isJacksonStdImpl(Object)//@JacksonStdImplpublic class StringDeserializer extends StdScalarDeserializer&lt;String&gt; &#123; private static final long serialVersionUID = 1L; public final static StringDeserializer instance = new StringDeserializer(); public StringDeserializer() &#123; super(String.class); &#125; // since 2.6, slightly faster lookups for this very common type @Override public boolean isCachable() &#123; return true; &#125; public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException &#123; JsonToken curr = jp.getCurrentToken(); if (curr == JsonToken.VALUE_STRING) &#123; return XssUtils.clean(jp.getText()); &#125; // Issue#381 if (curr == JsonToken.START_ARRAY &amp;&amp; ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) &#123; jp.nextToken(); final String parsed = _parseString(jp, ctxt); if (jp.nextToken() != JsonToken.END_ARRAY) &#123; throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, "Attempted to unwrap single value array for single 'String' value but there was more than a single value in the array"); &#125; return XssUtils.clean(parsed); &#125; // [JACKSON-330]: need to gracefully handle byte[] data, as base64 if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) &#123; Object ob = jp.getEmbeddedObject(); if (ob == null) &#123; return null; &#125; if (ob instanceof byte[]) &#123; return XssUtils.clean(Base64Variants.getDefaultVariant().encode((byte[]) ob, false)); &#125; // otherwise, try conversion using toString()... return XssUtils.clean(ob.toString()); &#125; // allow coercions for other scalar types String text = jp.getValueAsString(); if (text != null) &#123; return XssUtils.clean(text); &#125; throw ctxt.mappingException(_valueClass, curr); &#125; // Since we can never have type info ("natural type"; String, Boolean, // Integer, Double): // (is it an error to even call this version?) @Override public String deserializeWithType(JsonParser p, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException &#123; return deserialize(p, ctxt); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>xss</tag>
        <tag>antisamy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Java中使用xsd校验xml]]></title>
    <url>%2Farticles%2Fuse-schema-validate-xml-document-in-java%2F</url>
    <content type="text"><![CDATA[最近项目需要使用xsd对xml进行预校验，于是封装了一个工具类，来完成校验工作。完整代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.io.File;import java.io.IOException;import java.io.StringReader;import java.util.ArrayList;import java.util.List;import java.util.Locale;import javax.xml.XMLConstants;import javax.xml.transform.stream.StreamSource;import javax.xml.validation.Schema;import javax.xml.validation.SchemaFactory;import javax.xml.validation.Validator;import org.xml.sax.ErrorHandler;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;public class MultiSchemaValidator &#123; // private static final Logger logger = LoggerFactory.getLogger(MultiSchemaValidator.class); static&#123; System.setProperty("jdk.xml.maxOccurLimit", "9999"); //默认的maxOccur为5000，而我们项目中要求9999 Locale.setDefault(Locale.CHINA); //如果项目不考虑国际化的话 &#125; public static List&lt;SAXParseException&gt; validateXMLSchema(String xsdPath, String xml)&#123; final List&lt;SAXParseException&gt; errors = new ArrayList&lt;&gt;(); try &#123; SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI); String path = Thread.currentThread().getContextClassLoader().getResource("").getPath(); Schema schema = factory.newSchema(new File(path + xsdPath)); Validator validator = schema.newValidator(); validator.setErrorHandler(new ErrorHandler() &#123; @Override public void warning(SAXParseException exception) throws SAXException &#123;// logger.debug("warning ex", exception); &#125; @Override public void fatalError(SAXParseException exception) throws SAXException &#123;// logger.debug("fatalError ex", exception); &#125; @Override public void error(SAXParseException exception) throws SAXException &#123;// logger.debug("error ex", exception); errors.add(exception); &#125; &#125;); validator.validate(new StreamSource(new StringReader(xml))); &#125; catch (IOException | SAXException e) &#123; System.out.println("Exception: "+e.getMessage()); &#125; return errors; &#125; //测试代码 public static void main(String[] args) throws Exception &#123; String schemaURI = "xsd/Manifest.xsd"; String xml = ""; List&lt;SAXParseException&gt; errors = validateXMLSchema(schemaURI, xml); for(SAXParseException ex : errors)&#123; System.out.println(ex.getLineNumber() + "行," + ex.getColumnNumber() + "列," + ex.getMessage()); &#125; &#125;&#125;该代码应该可以完成一般需求。不过需要注意以下问题：xsd中使用&lt;xs:import&gt; &lt;xs:include&gt; 引入其他xsd文件时，不要将xsd打包到jar中，这种方式不支持jar!的方式访问import文件。jdk有xml-apis及其实现，但是尝试覆盖其XMLSchemaMessages.properties以便自定义提示语句时出现问题，便引用了 xml-apis 及 xercesImpl,覆盖了org.apache.xerces.impl.msg包下的properties文件。上述代码可以完成多schema文件的校验，需保证xsd都在相同路径。若不在同一位置，可参考链接中博客的方式，实现SchemaFactory解析shcema的处理操作。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>xsd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat下各日志文件的说明]]></title>
    <url>%2Farticles%2Fthe-log-files-of-tomcat%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天同事在使用tomcat发布项目的时候，遇到个问题，导致项目一直无法启动，查看tomcat控制台输出，发现启动日志仅有一句描述：严重: One or more listeners failed to start. Full details will be found in the appropriate container log file，第一时间认为是spring容器初始化失败，那么把spring加载配置文件及初始化的日志级别调整为debug不就万事大吉了么。&emsp;&emsp;然并卵，日志输出中还是仅有那一句描述，使用tomcat-manager卸载-发布-卸载-发布多个循环，仍无果。&emsp;&emsp;仔细思考想想，最近查问题都是使用catalina.out以及项目日志来排查，tomcat的其他日志中是不是藏有猫腻。&emsp;&emsp;最终在localhost.*.log中发现了问题，项目中spring容器扫描package时加载了不同包名但类名相同的bean，导致初始化监听器失败，可是为什么应用的日志组件已经启动，为什么没有报呢？还是翻翻spring、tomcat的源码瞧个仔细吧。经查阅，spring中contextloadlistener中的异常都是抛出到web容器的，由容器来进行处理，那么就可以定位到tomcat中standardcontext中初始化listener的位置，摘录如下：123456789101112131415161718192021for (int i = 0; i &lt; instances.length; i++) &#123; if (!(instances[i] instanceof ServletContextListener)) continue; ServletContextListener listener = (ServletContextListener) instances[i]; try &#123; fireContainerEvent("beforeContextInitialized", listener); if (noPluggabilityListeners.contains(listener)) &#123; listener.contextInitialized(tldEvent); &#125; else &#123; listener.contextInitialized(event); &#125; fireContainerEvent("afterContextInitialized", listener); &#125; catch (Throwable t) &#123; ExceptionUtils.handleThrowable(t); fireContainerEvent("afterContextInitialized", listener); getLogger().error (sm.getString("standardContext.listenerStart", instances[i].getClass().getName()), t); ok = false; &#125;&#125;&emsp;&emsp;好吧，如此可知道日志是通过standardcontext的父类ContainerBase来输出的，顺便瞅一眼tomcat的日志配置，默认为conf/logging.properties，看到该类的日志被输出到location.*.log中，与文首场景中对应上了。&emsp;&emsp;这么简单的问题查了小半天，惆怅。&emsp;&emsp;tomcat的相关文档中提示：调用javax.servlet.ServletContext.log(...)输出日志会被tomcat内部日志组件处理，按照日志配置文件中org.apache.catalina.core.ContainerBase.[${engine}].[${host}].[${context}] 的形式被分类记录，那我们顺便了解下tomcat默认的日志配置吧。1catalina.org.apache.juli.FileHandler.level = FINE1catalina.org.apache.juli.FileHandler.directory = ${catalina.base}/logs1catalina.org.apache.juli.FileHandler.prefix = catalina.2localhost.org.apache.juli.FileHandler.level = FINE2localhost.org.apache.juli.FileHandler.directory = ${catalina.base}/logs2localhost.org.apache.juli.FileHandler.prefix = localhost.3manager.org.apache.juli.FileHandler.level = FINE3manager.org.apache.juli.FileHandler.directory = ${catalina.base}/logs3manager.org.apache.juli.FileHandler.prefix = manager.4host-manager.org.apache.juli.FileHandler.level = FINE4host-manager.org.apache.juli.FileHandler.directory = ${catalina.base}/logs4host-manager.org.apache.juli.FileHandler.prefix = host-manager.&emsp;&emsp;另外，在conf/server.xml中我们可以开启请求记录日志，那么可以输出五个文件：1.catalina.yyyy-MM-dd.log Cataline引擎的日志文件，记录启动的JVM参数以及操作系统等信息2.localhost.yyyy-MM-dd.log tomcat中名为localhost的host日志输出，记录host初始化的日志3.localhost_access_log.yyyy-MM-dd.txt 记录localhost下各应用的请求4.host-manager.yyyy-MM-dd.log 记录localhost下host-manager的应用日志5.manager.yyyy-MM-dd.log 记录localhost下manager的应用日志]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在linux中使用源码安装httpd服务器]]></title>
    <url>%2Farticles%2Fhow-to-install-httpd-on-linux%2F</url>
    <content type="text"><![CDATA[前天在Centos中安装了Apache的httpd，安装的机器在公司内网，于是选择了源码进行安装。俗话说好记性不如烂笔头，现将安装过程进行记录，也希望能帮到各位网友。准备工作因公司机器已经安装c++编译相关，该工作不再赘述，如无法使用make相关命令，请自行安装g++、libc等库。笔者写这篇博文时选中的版本是httpd-2.4.23.tar.gzApache Portable Runtime（APR），为上层的应用程序提供一个可以跨平台使用的底层支持接口库。笔者选定的版本仍为官网最新版本apr-1.5.2.tar.gzapr-util-1.5.4.tar.gzpcre，该模块主要为httpd提供了rewrite功能，笔者选定了pcre-8.38.tar.gzlynx及其依赖ncurses，其中lynx是纯文本浏览器，httpd的执行status命令时会访问server-status，lynx用于解析html并输出文本信息，它依赖于ncurses，curses库是可以在Linux终端中写出字符用户界面，新的版本是ncurses库。不安装lynx及ncurses也可以，使用curl访问server-status链接即可。安装过程分别使用tar -xvzf命令解压缩各tar.gz，笔者将各压缩包解压在/opt/downloads下，依次执行以下的安装命令。安装ncurses(不使用lynx请跳过)1234cd /opt/downloads/ncurses-6.0/./configure --prefix=/usr/local/ncursesmakemake install安装lynx1234cd /opt/downloads/lynx2-8-8/./configure --prefix=/usr/local/lynx --with-curses-dir=/usr/local/ncursesmakemake install安装apr1234cd /opt/downloads/apr-1.5.2./configure --prefix=/usr/local/aprmakemake install安装apr-util1234cd /opt/downloads/apr-util-1.5.4./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/aprmakemake install安装pcre1234cd /opt/downloads/pcre-8.38./configure --with-apr=/usr/local/pcremakemake install安装httpd1234cd /opt/downloads/httpd-2.4.23./configure --prefix=/usr/local/apache2 --enable-expires --enable-headers --enable-modules=most --enable-so --with-mpm=worker --enable-rewrite --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util --with-pcre=/usr/local/pcremakemake install至此，httpd安装完毕。上面命令所使用到的./configure后的参数说明：（可执行./configure --help查看支持的参数，在执行./configure命令后，可使用echo $?查看是否有错误，返回0说明没问题，可继续执行make命令）#--prefix=&lt;install_path&gt; 指定便以后的二进制文件安装目录，若省略使用默认目录#--with-xxx 一般指定其加载的模块路径--enable-module=so 指明编译动态加载模块，使得apache的各模块与核心分开编译，运行时动态加载，最新版已缺省编译此模块--enable-deflate 支持网页压缩--enable-expires 通过配置文件控制HTTP的“Expires:”和“Cache-Control:”头内容，即对网站图片、js、css等内容，提供客户端浏览器缓存的设置--enable-rewrite 支持URL重写以下为本次未使用的参数说明：--enable-cache 支持缓存--enable-file-cache 支持文件缓存--enable-mem-cache 支持记忆缓存--enable-disk-cache 支持磁盘缓存--enable-static-support 支持静态连接(默认为动态连接)--enable-static-htpasswd 使用静态连接编译 htpasswd - 管理用于基本认证的用户文件--enable-static-htdigest 使用静态连接编译 htdigest - 管理用于摘要认证的用户文件--enable-static-rotatelogs 使用静态连接编译 rotatelogs - 滚动 Apache 日志的管道日志程序--enable-static-logresolve 使用静态连接编译 logresolve - 解析 Apache 日志中的IP地址为主机名--enable-static-htdbm 使用静态连接编译 htdbm - 操作 DBM 密码数据库--enable-static-ab 使用静态连接编译 ab - Apache HTTP 服务器性能测试工具--enable-static-checkgid 使用静态连接编译 checkgid--disable-cgid 禁止用一个外部 CGI 守护进程执行CGI脚本--disable-cgi 禁止编译 CGI 版本的 PHP--disable-userdir 禁止用户从自己的主目录中提供页面配置httpd修改httpd.conf文件去除ServerName的注释，并修改设置其值，如localhost:80若要开启server-status监控httpd的运行状态，需在httpd.conf中打开对httpd-info.conf的引用，并修改http-info.conf的相关配置，参照如下123456&lt;Location /server-status&gt; Order Deny,Allow Deny from all Allow from 127.0.0.1 &lt;/Location&gt;&gt;使用一下命令注册httpd为service1cp /usr/local/apache2/bin/apachectl /etc/init.d/httpd编辑/etc/init.d/httpd文件，在注释的顶部添加chkconfig的配置12# chkconfig:2345 90 90# description:Apache并为该文件添加可执行的权限1chmod +x /etc/init.d/httpd添加httpd为服务1chkconfig --add httpd现在可以使用service httpd start|stop|status等命令操作了Just enjoy it！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>httpd</tag>
      </tags>
  </entry>
</search>
