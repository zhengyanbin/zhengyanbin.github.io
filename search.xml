<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在Java中使用xsd校验xml]]></title>
    <url>%2Farticles%2Fuse-schema-validate-xml-document-in-java%2F</url>
    <content type="text"><![CDATA[最近项目需要使用xsd对xml进行预校验，于是封装了一个工具类，来完成校验工作。完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.io.File;import java.io.IOException;import java.io.StringReader;import java.util.ArrayList;import java.util.List;import java.util.Locale;import javax.xml.XMLConstants;import javax.xml.transform.stream.StreamSource;import javax.xml.validation.Schema;import javax.xml.validation.SchemaFactory;import javax.xml.validation.Validator;import org.xml.sax.ErrorHandler;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;public class MultiSchemaValidator &#123; // private static final Logger logger = LoggerFactory.getLogger(MultiSchemaValidator.class); static&#123; System.setProperty("jdk.xml.maxOccurLimit", "9999"); //默认的maxOccur为5000，而我们项目中要求9999 Locale.setDefault(Locale.CHINA); //如果项目不考虑国际化的话 &#125; public static List&lt;SAXParseException&gt; validateXMLSchema(String xsdPath, String xml)&#123; final List&lt;SAXParseException&gt; errors = new ArrayList&lt;&gt;(); try &#123; SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI); String path = Thread.currentThread().getContextClassLoader().getResource("").getPath(); Schema schema = factory.newSchema(new File(path + xsdPath)); Validator validator = schema.newValidator(); validator.setErrorHandler(new ErrorHandler() &#123; @Override public void warning(SAXParseException exception) throws SAXException &#123;// logger.debug("warning ex", exception); &#125; @Override public void fatalError(SAXParseException exception) throws SAXException &#123;// logger.debug("fatalError ex", exception); &#125; @Override public void error(SAXParseException exception) throws SAXException &#123;// logger.debug("error ex", exception); errors.add(exception); &#125; &#125;); validator.validate(new StreamSource(new StringReader(xml))); &#125; catch (IOException | SAXException e) &#123; System.out.println("Exception: "+e.getMessage()); &#125; return errors; &#125; //测试代码 public static void main(String[] args) throws Exception &#123; String schemaURI = "xsd/Manifest.xsd"; String xml = ""; List&lt;SAXParseException&gt; errors = validateXMLSchema(schemaURI, xml); for(SAXParseException ex : errors)&#123; System.out.println(ex.getLineNumber() + "行," + ex.getColumnNumber() + "列," + ex.getMessage()); &#125; &#125;&#125; 该代码应该可以完成一般需求。不过需要注意以下问题： xsd中使用&lt;xs:import&gt; &lt;xs:include&gt; 引入其他xsd文件时，不要将xsd打包到jar中，这种方式不支持jar!的方式访问import文件。 jdk有xml-apis及其实现，但是尝试覆盖其XMLSchemaMessages.properties以便自定义提示语句时出现问题，便引用了 xml-apis 及 xercesImpl,覆盖了org.apache.xerces.impl.msg包下的properties文件。 上述代码可以完成多schema文件的校验，需保证xsd都在相同路径。若不在同一位置，可参考链接中博客的方式，实现SchemaFactory解析shcema的处理操作。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>xsd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat下各日志文件的说明]]></title>
    <url>%2Farticles%2Fthe-log-files-of-tomcat%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天同事在使用tomcat发布项目的时候，遇到个问题，导致项目一直无法启动，查看tomcat控制台输出，发现启动日志仅有一句描述：严重: One or more listeners failed to start. Full details will be found in the appropriate container log file，第一时间认为是spring容器初始化失败，那么把spring加载配置文件及初始化的日志级别调整为debug不就万事大吉了么。&emsp;&emsp;然并卵，日志输出中还是仅有那一句描述，使用tomcat-manager卸载-发布-卸载-发布多个循环，仍无果。&emsp;&emsp;仔细思考想想，最近查问题都是使用catalina.out以及项目日志来排查，tomcat的其他日志中是不是藏有猫腻。&emsp;&emsp;最终在localhost.*.log中发现了问题，项目中spring容器扫描package时加载了不同包名但类名相同的bean，导致初始化监听器失败，可是为什么应用的日志组件已经启动，为什么没有报呢？还是翻翻spring、tomcat的源码瞧个仔细吧。经查阅，spring中contextloadlistener中的异常都是抛出到web容器的，由容器来进行处理，那么就可以定位到tomcat中standardcontext中初始化listener的位置，摘录如下： 123456789101112131415161718192021for (int i = 0; i &lt; instances.length; i++) &#123; if (!(instances[i] instanceof ServletContextListener)) continue; ServletContextListener listener = (ServletContextListener) instances[i]; try &#123; fireContainerEvent("beforeContextInitialized", listener); if (noPluggabilityListeners.contains(listener)) &#123; listener.contextInitialized(tldEvent); &#125; else &#123; listener.contextInitialized(event); &#125; fireContainerEvent("afterContextInitialized", listener); &#125; catch (Throwable t) &#123; ExceptionUtils.handleThrowable(t); fireContainerEvent("afterContextInitialized", listener); getLogger().error (sm.getString("standardContext.listenerStart", instances[i].getClass().getName()), t); ok = false; &#125;&#125; &emsp;&emsp;好吧，如此可知道日志是通过standardcontext的父类ContainerBase来输出的，顺便瞅一眼tomcat的日志配置，默认为conf/logging.properties，看到该类的日志被输出到location.*.log中，与文首场景中对应上了。&emsp;&emsp;这么简单的问题查了小半天，惆怅。&emsp;&emsp;tomcat的相关文档中提示：调用javax.servlet.ServletContext.log(...)输出日志会被tomcat内部日志组件处理，按照日志配置文件中org.apache.catalina.core.ContainerBase.[${engine}].[${host}].[${context}] 的形式被分类记录，那我们顺便了解下tomcat默认的日志配置吧。 1catalina.org.apache.juli.FileHandler.level = FINE1catalina.org.apache.juli.FileHandler.directory = ${catalina.base}/logs1catalina.org.apache.juli.FileHandler.prefix = catalina. 2localhost.org.apache.juli.FileHandler.level = FINE2localhost.org.apache.juli.FileHandler.directory = ${catalina.base}/logs2localhost.org.apache.juli.FileHandler.prefix = localhost. 3manager.org.apache.juli.FileHandler.level = FINE3manager.org.apache.juli.FileHandler.directory = ${catalina.base}/logs3manager.org.apache.juli.FileHandler.prefix = manager. 4host-manager.org.apache.juli.FileHandler.level = FINE4host-manager.org.apache.juli.FileHandler.directory = ${catalina.base}/logs4host-manager.org.apache.juli.FileHandler.prefix = host-manager. &emsp;&emsp;另外，在conf/server.xml中我们可以开启请求记录日志，那么可以输出五个文件：1.catalina.yyyy-MM-dd.log Cataline引擎的日志文件，记录启动的JVM参数以及操作系统等信息2.localhost.yyyy-MM-dd.log tomcat中名为localhost的host日志输出，记录host初始化的日志3.localhost_access_log.yyyy-MM-dd.txt 记录localhost下各应用的请求4.host-manager.yyyy-MM-dd.log 记录localhost下host-manager的应用日志5.manager.yyyy-MM-dd.log 记录localhost下manager的应用日志]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在linux中使用源码安装httpd服务器]]></title>
    <url>%2Farticles%2Fhow-to-install-httpd-on-linux%2F</url>
    <content type="text"><![CDATA[前天在Centos中安装了Apache的httpd，安装的机器在公司内网，于是选择了源码进行安装。俗话说好记性不如烂笔头，现将安装过程进行记录，也希望能帮到各位网友。 准备工作因公司机器已经安装c++编译相关，该工作不再赘述，如无法使用make相关命令，请自行安装g++、libc等库。 笔者写这篇博文时选中的版本是httpd-2.4.23.tar.gz Apache Portable Runtime（APR），为上层的应用程序提供一个可以跨平台使用的底层支持接口库。笔者选定的版本仍为官网最新版本apr-1.5.2.tar.gz apr-util-1.5.4.tar.gz pcre，该模块主要为httpd提供了rewrite功能，笔者选定了pcre-8.38.tar.gz lynx及其依赖ncurses，其中lynx是纯文本浏览器，httpd的执行status命令时会访问server-status，lynx用于解析html并输出文本信息，它依赖于ncurses，curses库是可以在Linux终端中写出字符用户界面，新的版本是ncurses库。不安装lynx及ncurses也可以，使用curl访问server-status链接即可。 安装过程分别使用tar -xvzf命令解压缩各tar.gz，笔者将各压缩包解压在/opt/downloads下，依次执行以下的安装命令。 安装ncurses(不使用lynx请跳过) 1234cd /opt/downloads/ncurses-6.0/./configure --prefix=/usr/local/ncursesmakemake install 安装lynx 1234cd /opt/downloads/lynx2-8-8/./configure --prefix=/usr/local/lynx --with-curses-dir=/usr/local/ncursesmakemake install 安装apr 1234cd /opt/downloads/apr-1.5.2./configure --prefix=/usr/local/aprmakemake install 安装apr-util 1234cd /opt/downloads/apr-util-1.5.4./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/aprmakemake install 安装pcre 1234cd /opt/downloads/pcre-8.38./configure --with-apr=/usr/local/pcremakemake install 安装httpd 1234cd /opt/downloads/httpd-2.4.23./configure --prefix=/usr/local/apache2 --enable-expires --enable-headers --enable-modules=most --enable-so --with-mpm=worker --enable-rewrite --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr-util --with-pcre=/usr/local/pcremakemake install 至此，httpd安装完毕。 上面命令所使用到的./configure后的参数说明：（可执行./configure --help查看支持的参数，在执行./configure命令后，可使用echo $?查看是否有错误，返回0说明没问题，可继续执行make命令） #--prefix=&lt;install_path&gt; 指定便以后的二进制文件安装目录，若省略使用默认目录 #--with-xxx 一般指定其加载的模块路径 --enable-module=so 指明编译动态加载模块，使得apache的各模块与核心分开编译，运行时动态加载，最新版已缺省编译此模块 --enable-deflate 支持网页压缩 --enable-expires 通过配置文件控制HTTP的“Expires:”和“Cache-Control:”头内容，即对网站图片、js、css等内容，提供客户端浏览器缓存的设置 --enable-rewrite 支持URL重写 以下为本次未使用的参数说明： --enable-cache 支持缓存 --enable-file-cache 支持文件缓存 --enable-mem-cache 支持记忆缓存 --enable-disk-cache 支持磁盘缓存 --enable-static-support 支持静态连接(默认为动态连接) --enable-static-htpasswd 使用静态连接编译 htpasswd - 管理用于基本认证的用户文件 --enable-static-htdigest 使用静态连接编译 htdigest - 管理用于摘要认证的用户文件 --enable-static-rotatelogs 使用静态连接编译 rotatelogs - 滚动 Apache 日志的管道日志程序 --enable-static-logresolve 使用静态连接编译 logresolve - 解析 Apache 日志中的IP地址为主机名 --enable-static-htdbm 使用静态连接编译 htdbm - 操作 DBM 密码数据库 --enable-static-ab 使用静态连接编译 ab - Apache HTTP 服务器性能测试工具 --enable-static-checkgid 使用静态连接编译 checkgid --disable-cgid 禁止用一个外部 CGI 守护进程执行CGI脚本 --disable-cgi 禁止编译 CGI 版本的 PHP --disable-userdir 禁止用户从自己的主目录中提供页面 配置httpd 修改httpd.conf文件 去除ServerName的注释，并修改设置其值，如localhost:80若要开启server-status监控httpd的运行状态，需在httpd.conf中打开对httpd-info.conf的引用，并修改http-info.conf的相关配置，参照如下 123456&lt;Location /server-status&gt; Order Deny,Allow Deny from all Allow from 127.0.0.1 &lt;/Location&gt;&gt; 使用一下命令注册httpd为service 1cp /usr/local/apache2/bin/apachectl /etc/init.d/httpd 编辑/etc/init.d/httpd文件，在注释的顶部添加chkconfig的配置12# chkconfig:2345 90 90# description:Apache 并为该文件添加可执行的权限1chmod +x /etc/init.d/httpd 添加httpd为服务1chkconfig --add httpd 现在可以使用service httpd start|stop|status等命令操作了 Just enjoy it！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>httpd</tag>
      </tags>
  </entry>
</search>
